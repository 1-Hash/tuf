"""
<Program Name>
  pycrypto_keys.py

<Author>
  Vladimir Diaz <vladimir.v.diaz@gmail.com>

<Started>
  March 7, 2013.

<Copyright>
  See LICENSE for licensing information.

<Purpose>
  The goal of this module is to support public-key cryptography using the RSA
  algorithm.  The RSA-related functions provided include generate(),
  create_signature(), and verify_signature().  The create_encrypted_pem() and
  create_from_encrypted_pem() functions are optional, and may be used save a
  generated RSA key to a file.  The 'PyCrypto' package used by 'rsa_key.py'
  generates the actual RSA keys and the functions listed above can be viewed
  as an easy-to-use public interface.  Additional functions contained here
  include create_in_metadata_format() and create_from_metadata_format().  These
  last two functions produce or use RSA keys compatible with the key structures
  listed in TUF Metadata files.  The generate() function returns a dictionary
  containing all the information needed of RSA keys, such as public and private=
  keys, keyIDs, and an idenfier.  create_signature() and verify_signature() are
  supplemental functions used for generating RSA signatures and verifying them.
  https://en.wikipedia.org/wiki/RSA_(algorithm)
 """

# Crypto.PublicKey (i.e., PyCrypto public-key cryptography) provides algorithms
# such as Digital Signature Algorithm (DSA) and the ElGamal encryption system.
# 'Crypto.PublicKey.RSA' is needed here to generate, sign, and verify RSA keys.
import Crypto.PublicKey.RSA

# PyCrypto requires 'Crypto.Hash' hash objects to generate PKCS#1 PSS
# signatures (i.e., Crypto.Signature.PKCS1_PSS).
import Crypto.Hash.SHA256

# RSA's probabilistic signature scheme with appendix (RSASSA-PSS).
# PKCS#1 v1.5 is provided for compatability with existing applications, but
# RSASSA-PSS is encouraged for newer applications.  RSASSA-PSS generates
# a random salt to ensure the signature generated is probabilistic rather than
# deterministic, like PKCS#1 v1.5.
# http://en.wikipedia.org/wiki/RSA-PSS#Schemes 
# https://tools.ietf.org/html/rfc3447#section-8.1 
import Crypto.Signature.PKCS1_PSS

import tuf

# Digest objects needed to generate hashes.
import tuf.hash

# Perform object format-checking.
import tuf.formats

# Recommended RSA key sizes:
# http://www.emc.com/emc-plus/rsa-labs/historical/twirl-and-rsa-key-size.htm#table1
# According to the document above, revised May 6, 2003, RSA keys of
# size 3072 provide security through 2031 and beyond.
_DEFAULT_RSA_KEY_BITS = 3072 


def generate_rsa_public_and_private(bits=_DEFAULT_RSA_KEY_BITS):
  """
  <Purpose> 
    Generate public and private RSA keys, with modulus length 'bits'.
    In addition, a keyid used as an identifier for RSA keys is generated.
    The object returned conforms to 'tuf.formats.RSAKEY_SCHEMA' and as the form:
    {'keytype': 'rsa',
     'keyid': keyid,
     'keyval': {'public': '-----BEGIN RSA PUBLIC KEY----- ...',
                'private': '-----BEGIN RSA PRIVATE KEY----- ...'}}
    
    The public and private keys are in PEM format and stored as strings.

    Although the crytography library called sets a 1024-bit minimum key size,
    generate() enforces a minimum key size of 2048 bits.  If 'bits' is
    unspecified, a 3072-bit RSA key is generated, which is the key size
    recommended by TUF. 
  
  <Arguments>
    bits:
      The key size, or key length, of the RSA key.  'bits' must be 2048, or
      greater, and a multiple of 256.

  <Exceptions>
    ValueError, if an exception occurs after calling the RSA key generation
    routine.  'bits' must be a multiple of 256.  The 'ValueError' exception is
    raised by the key generation function of the cryptography library called.

    tuf.FormatError, if 'bits' does not contain the correct format.

  <Side Effects>
    The RSA keys are generated by calling PyCrypto's
    Crypto.PublicKey.RSA.generate().

  <Returns>
    A dictionary containing the RSA keys and other identifying information.
  """

  # Does 'bits' have the correct format?
  # This check will ensure 'bits' conforms to 'tuf.formats.RSAKEYBITS_SCHEMA'.
  # 'bits' must be an integer object, with a minimum value of 2048.
  # Raise 'tuf.FormatError' if the check fails.
  tuf.formats.RSAKEYBITS_SCHEMA.check_match(bits)
  
  # Generate the public and private RSA keys.  The PyCrypto module performs
  # the actual key generation.  Raise 'ValueError' if 'bits' is less than 1024 
  # or not a multiple of 256, although a 2048-bit minimum is enforced by
  # tuf.formats.RSAKEYBITS_SCHEMA.check_match().
  rsa_key_object = Crypto.PublicKey.RSA.generate(bits)
  
  # Extract the public & private halves of the RSA key and generate their
  # PEM-formatted representations.  The dictionary returned contains the 
  # private and public RSA keys in PEM format, as strings.
  private_key = rsa_key_object.exportKey(format='PEM') 
  rsa_pubkey = rsa_key_object.publickey()
  public_key = rsa_pubkey.exportKey(format='PEM')

  return public_key, private_key





def create_signature(private_key, data):
  """
  <Purpose>
    Return a signature dictionary of the form:
    {'keyid': keyid,
     'method': 'PyCrypto-PKCS#1 PPS',
     'sig': sig}.

    The signing process will use the private key
    rsakey_dict['keyval']['private'] and 'data' to generate the signature.

    RFC3447 - RSASSA-PSS 
    http://www.ietf.org/rfc/rfc3447.txt

  <Arguments>
    private_key: 
      The private key is a string in PEM format.

    data:
      Data object used by create_signature() to generate the signature.

  <Exceptions>
    TypeError, if a private key is not defined for 'rsakey_dict'.

    tuf.FormatError, if an incorrect format is found for 'private_key'.

    tuf.CryptoError, 

  <Side Effects>
    PyCrypto's 'Crypto.Signature.PKCS1_PSS' called to generate the signature.

  <Returns>
    A (signature, method) tuple, where
  """

  # Signing the 'data' object requires a private key.
  # The 'PyCrypto-PKCS#1 PSS' (i.e., PyCrypto module) signing method is the
  # only method currently supported.
  private = private_key
  method = 'PyCrypto-PKCS#1 PSS'
  signature = None
 
  # Verify the signature, but only if the private key has been set.  The private
  # key is a NULL string if unset.  Although it may be clearer to explicit check
  # that 'private_key' is not '', we can/should check for a value and not
  # compare identities with the 'is' keyword. 
  if len(private_key):
    # Calculate the SHA256 hash of 'data' and generate the hash's PKCS1-PSS
    # signature. 
    try:
      rsa_key_object = Crypto.PublicKey.RSA.importKey(private_key)
      sha256_object = Crypto.Hash.SHA256.new(data)
      pkcs1_pss_signer = Crypto.Signature.PKCS1_PSS.new(rsa_key_object)
      sig = pkcs1_pss_signer.sign(sha256_object)
    except (ValueError, IndexError, TypeError), e:
      message = 'An RSA signature could not be generated.'
      raise tuf.CryptoError(message)
  else:
    raise TypeError('The required private key is not defined for "rsakey_dict".')

  return signature, method





def verify_signature(signature, signature_method, public_key, data):
  """
  <Purpose>
    Determine whether the private key belonging to 'rsakey_dict' produced
    'signature'.  verify_signature() will use the public key found in
    'rsakey_dict', the 'method' and 'sig' objects contained in 'signature',
    and 'data' to complete the verification.  Type-checking performed on both
    'rsakey_dict' and 'signature'.

  <Arguments>
    signature:
      The signature dictionary produced by tuf.rsa_key.create_signature().
      'signature' has the form:
      {'keyid': keyid, 'method': 'method', 'sig': sig}.  Conformant to
      'tuf.formats.SIGNATURE_SCHEMA'.
      
    signature_method:

    public_key:

    data:
      Data object used by tuf.rsa_key.create_signature() to generate
      'signature'.  'data' is needed here to verify the signature.

  <Exceptions>
    tuf.UnknownMethodError.  Raised if the signing method used by
    'signature' is not one supported by tuf.rsa_key.create_signature().
    
    tuf.FormatError. Raised if either 'rsakey_dict'
    or 'signature' do not match their respective tuf.formats schema.
    'rsakey_dict' must conform to 'tuf.formats.RSAKEY_SCHEMA'.
    'signature' must conform to 'tuf.formats.SIGNATURE_SCHEMA'.

  <Side Effects>
    Crypto.Signature.PKCS1_PSS.verify() called to do the actual verification.

  <Returns>
    Boolean.  True if the signature is valid, False otherwise.
  """

  # Using the public key belonging to 'rsakey_dict'
  # (i.e., rsakey_dict['keyval']['public']), verify whether 'signature'
  # was produced by rsakey_dict's corresponding private key
  # rsakey_dict['keyval']['private'].  Before returning the Boolean result,
  # ensure 'PyCrypto-PKCS#1 PSS' was used as the signing method.
  signature = signature
  method = signature_method
  public = public_key
  valid_signature = False

  if method == 'PyCrypto-PKCS#1 PSS':
    try:
      rsa_key_object = Crypto.PublicKey.RSA.importKey(public_key)
      pkcs1_pss_verifier = Crypto.Signature.PKCS1_PSS.new(rsa_key_object)
      sha256_object = Crypto.Hash.SHA256.new(data)
      
      valid_signature = pkcs1_pss_verifier.verify(sha256_object, signature)
    except (ValueError, IndexError, TypeError), e:
      message = 'The RSA signature could not be verified.'
      raise tuf.CryptoError(message)
  else:
    raise tuf.UnknownMethodError(method)

  return valid_signature 





def create_rsa_encrypted_pem(private_key, passphrase):
  """
  <Purpose>
    Return a string in PEM format, where the private part of the RSA key is
    encrypted.  The private part of the RSA key is encrypted by the Triple
    Data Encryption Algorithm (3DES) and Cipher-block chaining (CBC) for the 
    mode of operation.  Password-Based Key Derivation Function 1 (PBKF1) + MD5
    is used to strengthen 'passphrase'.

    https://en.wikipedia.org/wiki/Triple_DES
    https://en.wikipedia.org/wiki/PBKDF2

  <Arguments>
    private_key:
      The public and private keys are in PEM format and stored as strings.

    passphrase:
      The passphrase, or password, to encrypt the private part of the RSA
      key.  'passphrase' is not used directly as the encryption key, a stronger
      encryption key is derived from it. 

  <Exceptions>
    TypeError, if a private key is not defined for 'rsakey_dict'.

    tuf.FormatError, if an incorrect format is found for 'rsakey_dict'.

  <Side Effects>
    PyCrypto's Crypto.PublicKey.RSA.exportKey() called to perform the actual
    generation of the PEM-formatted output.

  <Returns>
    A string in PEM format, where the private RSA key is encrypted.
  """
  
  # Does 'rsakey_dict' have the correct format?
  # This check will ensure 'rsakey_dict' has the appropriate number
  # of objects and object types, and that all dict keys are properly named.
  # Raise 'tuf.FormatError' if the check fails.
  tuf.formats.RSAKEY_SCHEMA.check_match(rsakey_dict)
  
  # Does 'signature' have the correct format?
  tuf.formats.PASSWORD_SCHEMA.check_match(passphrase)

  # Extract the private key from 'rsakey_dict', which is stored in PEM format
  # and unencrypted.  The extracted key will be imported and converted to
  # PyCrypto's RSA key object (i.e., Crypto.PublicKey.RSA).Use PyCrypto's
  # exportKey method, with a passphrase specified, to create the string.
  # PyCrypto uses PBKDF1+MD5 to strengthen 'passphrase', and 3DES with CBC mode
  # for encryption.    
  try:
    rsa_key_object = Crypto.PublicKey.RSA.importKey(private_key)
    encrypted_pem = rsa_key_object.exportKey(format='PEM', passphrase=passphrase) 
  except (ValueError, IndexError, TypeError), e:
    message = 'An encrypted RSA key in PEM format could not be generated.'
    raise tuf.CryptoError(message)

  return encrypted_pem





def create_rsa_from_encrypted_pem(encrypted_pem, passphrase):
  """
  <Purpose>
    Return an RSA key in 'tuf.formats.RSAKEY_SCHEMA' format, which has the
    form:
      {'keytype': 'rsa',
       'keyid': keyid,
       'keyval': {'public': '-----BEGIN RSA PUBLIC KEY----- ...',
                  'private': '-----BEGIN RSA PRIVATE KEY----- ...'}}
    
    The RSAKEY_SCHEMA object is generated from a byte string in PEM format,
    where the private part of the RSA key is encrypted.  PyCrypto's importKey
    method is used, where a passphrase is specified.  PyCrypto uses PBKDF1+MD5
    to strengthen 'passphrase', and 3DES with CBC mode for encryption/decryption.    
    Alternatively, key data may be encrypted with AES-CTR-Mode and the passphrase
    strengthened with PBKDF2+SHA256.  See 'keystore.py'.

  <Arguments>
    encrypted_pem:
      A byte string in PEM format, where the private key is encrypted.  It has
      the form:
      
      '-----BEGIN RSA PRIVATE KEY-----\n
      Proc-Type: 4,ENCRYPTED\nDEK-Info: DES-EDE3-CBC ...'

    passphrase:
      The passphrase, or password, to decrypt the private part of the RSA
      key.  'passphrase' is not directly used as the encryption key, instead
      it is used to derive a stronger symmetric key.

  <Exceptions>
    TypeError, if a private key is not defined for 'rsakey_dict'.

    tuf.FormatError, if an incorrect format is found for the
    'rsakey_dict' object.

  <Side Effects>
    PyCrypto's 'Crypto.PublicKey.RSA.importKey()' called to perform the actual
    conversion from an encrypted RSA private key.

  <Returns>
    A dictionary in 'tuf.formats.RSAKEY_SCHEMA' format.
  """
  
  # Does 'encryped_pem' have the correct format?
  # This check will ensure 'encrypted_pem' has the appropriate number
  # of objects and object types, and that all dict keys are properly named.
  # Raise 'tuf.FormatError' if the check fails.
  tuf.formats.PEMRSA_SCHEMA.check_match(encrypted_pem)

  # Does 'passphrase' have the correct format?
  tuf.formats.PASSWORD_SCHEMA.check_match(passphrase)
  
  try:
    rsa_key_object = Crypto.PublicKey.RSA.importKey(encrypted_pem, passphrase)
  except (ValueError, IndexError, TypeError), e:
    message = 'An RSA key object could not be generated from the encrypted '+\
      'PEM string.'
    # Raise 'tuf.CryptoError' instead of PyCrypto's exception to avoid
    # revealing sensitive error, such as a decryption error due to an
    # invalid passphrase.
    raise tuf.CryptoError(message)

  # Extract the public and private halves of the RSA key and generate their
  # PEM-formatted representations.  The dictionary returned contains the 
  # private and public RSA keys in PEM format, as strings.
  private = rsa_key_object.exportKey(format='PEM') 
  rsa_pubkey = rsa_key_object.publickey()
  public = rsa_pubkey.exportKey(format='PEM')

  return public, private



if __name__ == '__main__':
  # The interactive sessions of the documentation strings can
  # be tested by running 'pycrypto_keys.py' as a standalone module.
  # python -B pycrypto_keys.py
  import doctest
  doctest.testmod()
